<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Water Shader with Reflection/Refraction (Approx)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: monospace;
            z-index: 100; /* Ensure it's on top */
        }
    </style>
</head>
<body>
    <div id="info">Drag to navigate</div>
    <canvas id="webgl-canvas"></canvas>

    <script type="module">
        // Import Three.js and OrbitControls from CDN
        import * as THREE from 'https://unpkg.com/three@0.163.0/build/three.module.js';
        import { OrbitControls } from 'https://unpkg.com/three@0.163.0/examples/jsm/controls/OrbitControls.js';

        // --- Shader Code ---

        const waterVertexShader = `
            uniform float uTime;
            uniform float uWaveFrequency;
            uniform float uWaveAmplitude;
            uniform float uWaveSpeed;

            varying vec3 vWorldPosition;
            varying vec3 vNormal;
            varying vec2 vUv; // Pass UV for potential texture use

            // Simple Gerstner Wave function (or sine wave approx)
            // Returns vec3(x_offset, y_offset, z_height)
            // More complex waves can be layered here
            vec3 gerstnerWave(vec2 position, float steepness, float amplitude, float frequency, vec2 direction, float speed, float time) {
                float k = 2.0 * 3.14159265 / (1.0 / frequency); // Wave number from frequency
                float c = sqrt(9.8 / k) * speed; // Phase speed (simplified)
                vec2 d = normalize(direction);
                float f = k * (dot(d, position) - c * time);
                float a = steepness * amplitude;

                return vec3(
                    -d.x * a * cos(f),
                    -d.y * a * cos(f),
                    amplitude * sin(f)
                );
            }

            void main() {
                vUv = uv;
                vec4 modelPos = modelMatrix * vec4(position, 1.0);

                // --- Wave Generation ---
                // Define multiple wave parameters for complexity
                float time = uTime * uWaveSpeed;
                vec3 wave1 = gerstnerWave(modelPos.xz, 0.5, uWaveAmplitude * 0.6, uWaveFrequency * 1.2, vec2(1.0, 0.5), 1.0, time);
                vec3 wave2 = gerstnerWave(modelPos.xz, 0.4, uWaveAmplitude * 0.4, uWaveFrequency * 0.8, vec2(0.5, -1.0), 1.2, time);
                vec3 wave3 = gerstnerWave(modelPos.xz, 0.2, uWaveAmplitude * 0.1, uWaveFrequency * 2.5, vec2(-0.3, 0.8), 1.5, time);

                // Combine waves
                vec3 totalDisplacement = wave1 + wave2 + wave3;
                modelPos.xyz += totalDisplacement;

                // --- Normal Calculation (Approximate) ---
                // Calculate normals by sampling wave height at nearby points (finite differencing)
                // More accurate but complex: Calculate analytically from Gerstner wave derivatives
                float eps = 0.01; // Small offset for sampling
                vec3 posPlusX = modelPos.xyz + vec3(eps, 0.0, 0.0);
                vec3 posMinusX = modelPos.xyz - vec3(eps, 0.0, 0.0);
                vec3 posPlusZ = modelPos.xyz + vec3(0.0, 0.0, eps);
                vec3 posMinusZ = modelPos.xyz - vec3(0.0, 0.0, eps);

                // Sample heights at offset positions
                float heightPlusX = gerstnerWave(posPlusX.xz, 0.5, uWaveAmplitude * 0.6, uWaveFrequency * 1.2, vec2(1.0, 0.5), 1.0, time).z +
                                     gerstnerWave(posPlusX.xz, 0.4, uWaveAmplitude * 0.4, uWaveFrequency * 0.8, vec2(0.5, -1.0), 1.2, time).z +
                                     gerstnerWave(posPlusX.xz, 0.2, uWaveAmplitude * 0.1, uWaveFrequency * 2.5, vec2(-0.3, 0.8), 1.5, time).z;

                float heightMinusX = gerstnerWave(posMinusX.xz, 0.5, uWaveAmplitude * 0.6, uWaveFrequency * 1.2, vec2(1.0, 0.5), 1.0, time).z +
                                      gerstnerWave(posMinusX.xz, 0.4, uWaveAmplitude * 0.4, uWaveFrequency * 0.8, vec2(0.5, -1.0), 1.2, time).z +
                                      gerstnerWave(posMinusX.xz, 0.2, uWaveAmplitude * 0.1, uWaveFrequency * 2.5, vec2(-0.3, 0.8), 1.5, time).z;

                float heightPlusZ = gerstnerWave(posPlusZ.xz, 0.5, uWaveAmplitude * 0.6, uWaveFrequency * 1.2, vec2(1.0, 0.5), 1.0, time).z +
                                     gerstnerWave(posPlusZ.xz, 0.4, uWaveAmplitude * 0.4, uWaveFrequency * 0.8, vec2(0.5, -1.0), 1.2, time).z +
                                     gerstnerWave(posPlusZ.xz, 0.2, uWaveAmplitude * 0.1, uWaveFrequency * 2.5, vec2(-0.3, 0.8), 1.5, time).z;

                float heightMinusZ = gerstnerWave(posMinusZ.xz, 0.5, uWaveAmplitude * 0.6, uWaveFrequency * 1.2, vec2(1.0, 0.5), 1.0, time).z +
                                      gerstnerWave(posMinusZ.xz, 0.4, uWaveAmplitude * 0.4, uWaveFrequency * 0.8, vec2(0.5, -1.0), 1.2, time).z +
                                      gerstnerWave(posMinusZ.xz, 0.2, uWaveAmplitude * 0.1, uWaveFrequency * 2.5, vec2(-0.3, 0.8), 1.5, time).z;


                // Calculate tangent and bitangent (simplified based on height differences)
                vec3 tangent = normalize(vec3(2.0 * eps, heightPlusX - heightMinusX, 0.0));
                vec3 bitangent = normalize(vec3(0.0, heightPlusZ - heightMinusZ, 2.0 * eps));

                // Calculate the normal using the cross product
                vec3 perturbedNormal = normalize(cross(bitangent, tangent));

                // Transform normal to world space
                vNormal = normalize(mat3(modelMatrix) * perturbedNormal); // Pass world normal

                // Pass world position to fragment shader
                vWorldPosition = modelPos.xyz;

                // Final position
                gl_Position = projectionMatrix * viewMatrix * modelPos;
            }
        `;

        const waterFragmentShader = `
            uniform float uTime;
            uniform samplerCube tCube; // Reflection map (skybox)
            uniform vec3 uWaterColor;
            uniform vec3 uCameraPosition;
            uniform vec3 uLightDirection; // Normalized light direction

            varying vec3 vWorldPosition;
            varying vec3 vNormal;
            varying vec2 vUv; // Receive UV

            // Schlick approximation for Fresnel
            float fresnelSchlick(float cosTheta, float F0) {
                return F0 + (1.0 - F0) * pow(max(1.0 - cosTheta, 0.0), 5.0);
            }

            void main() {
                vec3 normal = normalize(vNormal);
                vec3 viewDirection = normalize(uCameraPosition - vWorldPosition);

                // --- Reflection ---
                vec3 reflectDirection = reflect(-viewDirection, normal);
                // Sample the reflection map (skybox)
                vec4 reflectionColor = textureCube(tCube, reflectDirection);

                // --- Refraction (Approximate) ---
                // We approximate refraction by sampling the skybox again,
                // but slightly perturbing the sample direction based on the normal.
                // This simulates distortion without needing a separate scene render pass.
                // A more realistic approach would sample a texture containing the scene below the water.
                float refractionRatio = 1.0 / 1.33; // Air to Water IOR (approx)
                vec3 refractDirection = refract(-viewDirection, normal, refractionRatio);
                // Add some distortion based on normal offset - simple but effective visual cue
                vec2 distortion = normal.xz * 0.05; // Tweak strength of distortion
                vec3 distortedRefractDir = normalize(refractDirection + vec3(distortion.x, 0.0, distortion.y));
                vec4 refractionColor = textureCube(tCube, distortedRefractDir);


                // --- Fresnel ---
                // Calculate how much reflection vs refraction based on viewing angle
                float cosTheta = max(dot(viewDirection, normal), 0.0);
                float F0 = 0.02; // Base reflectivity for water at normal incidence
                float fresnelFactor = fresnelSchlick(cosTheta, F0);

                // --- Lighting (Simple Lambertian + Specular) ---
                vec3 lightDir = normalize(uLightDirection);
                float diffuse = max(dot(normal, lightDir), 0.0);

                // Simple Blinn-Phong specular highlight
                vec3 halfwayDir = normalize(lightDir + viewDirection);
                float specAngle = max(dot(normal, halfwayDir), 0.0);
                float specular = pow(specAngle, 32.0); // Shininess factor

                vec3 lightColor = vec3(1.0); // White light
                vec3 ambient = vec3(0.1) * uWaterColor; // Add some ambient light

                // Combine diffuse and specular lighting, modulated by water color
                vec3 lighting = ambient + (diffuse * uWaterColor + specular * lightColor) * 0.8; // Adjust intensity

                // --- Final Color Combination ---
                // Blend reflection and refraction based on Fresnel
                vec3 surfaceColor = mix(refractionColor.rgb * lighting, reflectionColor.rgb, fresnelFactor);

                // Combine lighting with surface properties
                vec3 finalColor = surfaceColor; // Use the mix result directly

                // Add a subtle depth fog / color based on depth (optional)
                // float depth = gl_FragCoord.z / gl_FragCoord.w; // Linear depth approx
                // float fogFactor = smoothstep(10.0, 50.0, depth); // Adjust fog range
                // finalColor = mix(finalColor, uWaterColor * 0.8, fogFactor);


                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;

        // --- Three.js Setup ---

        let scene, camera, renderer, controls;
        let waterMesh, cubeCamera, waterMaterial;
        const clock = new THREE.Clock();

        // Check if canvas exists
        const canvas = document.getElementById('webgl-canvas');
        if (!canvas) {
            console.error("Error: Canvas element with id 'webgl-canvas' not found.");
            throw new Error("Canvas not found");
        }

        function init() {
            // Scene
            scene = new THREE.Scene();

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(10, 15, 20); // Start further out
            camera.lookAt(scene.position);

            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            // Important for color accuracy with CubeTexture
            renderer.outputColorSpace = THREE.SRGBColorSpace;

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // Smooth camera movement
            controls.dampingFactor = 0.05;
            controls.target.set(0, 0, 0); // Look at the center

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(5, 10, 7);
            scene.add(directionalLight);
            const lightDirection = directionalLight.position.clone().normalize(); // For shader


            // Skybox / Environment Map
            const cubeTextureLoader = new THREE.CubeTextureLoader();
            const skyboxTexture = cubeTextureLoader.load([
                'https://threejs.org/examples/textures/cube/skyboxsun25deg/px.jpg', // pos-x
                'https://threejs.org/examples/textures/cube/skyboxsun25deg/nx.jpg', // neg-x
                'https://threejs.org/examples/textures/cube/skyboxsun25deg/py.jpg', // pos-y
                'https://threejs.org/examples/textures/cube/skyboxsun25deg/ny.jpg', // neg-y
                'https://threejs.org/examples/textures/cube/skyboxsun25deg/pz.jpg', // pos-z
                'https://threejs.org/examples/textures/cube/skyboxsun25deg/nz.jpg'  // neg-z
            ]);
            skyboxTexture.colorSpace = THREE.SRGBColorSpace; // Match renderer output
            scene.background = skyboxTexture;

            // CubeCamera for dynamic reflections (uses the scene.background)
            const cubeRenderTarget = new THREE.WebGLCubeRenderTarget( 512 ); // Reflection resolution
            cubeRenderTarget.texture.type = THREE.HalfFloatType; // Optional: Better precision
            cubeCamera = new THREE.CubeCamera( 1, 1000, cubeRenderTarget );


            // Water Geometry
            const waterGeometry = new THREE.PlaneGeometry(100, 100, 100, 100); // Size and segmentation

            // Water Material
            try {
                waterMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        uTime: { value: 0.0 },
                        tCube: { value: cubeRenderTarget.texture }, // Reflection map
                        uWaterColor: { value: new THREE.Color(0x004f6e) }, // Deep blue water color
                        uCameraPosition: { value: camera.position }, // Pass camera position
                        uLightDirection: { value: lightDirection }, // Pass light direction
                        uWaveFrequency: { value: 0.03 }, // Controls density of waves
                        uWaveAmplitude: { value: 0.3 }, // Controls height of waves
                        uWaveSpeed: { value: 0.5 } // Controls speed of waves
                    },
                    vertexShader: waterVertexShader,
                    fragmentShader: waterFragmentShader,
                    transparent: false, // Usually false for water main body, transparency can be faked with Fresnel
                    side: THREE.DoubleSide // Render both sides if needed
                });
            } catch (error) {
                console.error("Error creating ShaderMaterial:", error);
                alert(`Shader Compilation Error: ${error.message}\nCheck console for details.`);
                throw error;
            }

            // Water Mesh
            waterMesh = new THREE.Mesh(waterGeometry, waterMaterial);
            waterMesh.rotation.x = -Math.PI / 2; // Rotate plane to be horizontal
            scene.add(waterMesh);

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
        }

        // Animation Loop
        function animate() {
            requestAnimationFrame(animate);

            const elapsedTime = clock.getElapsedTime();

            // Update uniforms
            if (waterMaterial) {
                waterMaterial.uniforms.uTime.value = elapsedTime;
                // Update camera position uniform continuously
                waterMaterial.uniforms.uCameraPosition.value.copy(camera.position);
            }

             // Update Reflection Map
            if (waterMesh && cubeCamera) {
                waterMesh.visible = false; // Hide water surface before rendering reflection
                cubeCamera.position.copy(camera.position); // Match cube camera position (optional, depends on desired effect)
                cubeCamera.update(renderer, scene); // Render scene to cubemap
                waterMesh.visible = true; // Make water visible again for final render
            }


            // Update controls
            controls.update();

            // Render final scene
            renderer.render(scene, camera);
        }

        // Resize Handler
        function onWindowResize() {
            if (!camera || !renderer) return;

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
        }

        // Start
        try {
            init();
            animate();
        } catch (error) {
            console.error("Initialization or Animation failed:", error);
            document.body.innerHTML = `<div style="color: red; padding: 20px; font-family: sans-serif;">
                <h2>Application Error</h2>
                <p>Could not initialize the WebGL application. Please ensure your browser supports WebGL and check the console (F12) for details.</p>
                <pre style="white-space: pre-wrap;">${error.stack || error.message}</pre>
            </div>`;
        }

    </script>
</body>
</html>